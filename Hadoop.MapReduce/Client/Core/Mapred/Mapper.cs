using Org.Apache.Hadoop.IO;
using Sharpen;

namespace Org.Apache.Hadoop.Mapred
{
	/// <summary>Maps input key/value pairs to a set of intermediate key/value pairs.</summary>
	/// <remarks>
	/// Maps input key/value pairs to a set of intermediate key/value pairs.
	/// <p>Maps are the individual tasks which transform input records into a
	/// intermediate records. The transformed intermediate records need not be of
	/// the same type as the input records. A given input pair may map to zero or
	/// many output pairs.</p>
	/// <p>The Hadoop Map-Reduce framework spawns one map task for each
	/// <see cref="InputSplit"/>
	/// generated by the
	/// <see cref="InputFormat{K, V}"/>
	/// for the job.
	/// <code>Mapper</code> implementations can access the
	/// <see cref="JobConf"/>
	/// for the
	/// job via the
	/// <see cref="JobConfigurable.Configure(JobConf)"/>
	/// and initialize
	/// themselves. Similarly they can use the
	/// <see cref="System.IDisposable.Close()"/>
	/// method for
	/// de-initialization.</p>
	/// <p>The framework then calls
	/// <see cref="Mapper{K1, V1, K2, V2}.Map(object, object, OutputCollector{K, V}, Reporter)
	/// 	"/>
	/// 
	/// for each key/value pair in the <code>InputSplit</code> for that task.</p>
	/// <p>All intermediate values associated with a given output key are
	/// subsequently grouped by the framework, and passed to a
	/// <see cref="Reducer{K2, V2, K3, V3}"/>
	/// to
	/// determine the final output. Users can control the grouping by specifying
	/// a <code>Comparator</code> via
	/// <see cref="JobConf.SetOutputKeyComparatorClass(System.Type{T})"/>
	/// .</p>
	/// <p>The grouped <code>Mapper</code> outputs are partitioned per
	/// <code>Reducer</code>. Users can control which keys (and hence records) go to
	/// which <code>Reducer</code> by implementing a custom
	/// <see cref="Partitioner{K2, V2}"/>
	/// .
	/// <p>Users can optionally specify a <code>combiner</code>, via
	/// <see cref="JobConf.SetCombinerClass(System.Type{T})"/>
	/// , to perform local aggregation of the
	/// intermediate outputs, which helps to cut down the amount of data transferred
	/// from the <code>Mapper</code> to the <code>Reducer</code>.
	/// <p>The intermediate, grouped outputs are always stored in
	/// <see cref="Org.Apache.Hadoop.IO.SequenceFile"/>
	/// s. Applications can specify if and how the intermediate
	/// outputs are to be compressed and which
	/// <see cref="Org.Apache.Hadoop.IO.Compress.CompressionCodec"/>
	/// s are to be
	/// used via the <code>JobConf</code>.</p>
	/// <p>If the job has
	/// &lt;a href="
	/// <docRoot/>
	/// /org/apache/hadoop/mapred/JobConf.html#ReducerNone"&gt;zero
	/// reduces</a> then the output of the <code>Mapper</code> is directly written
	/// to the
	/// <see cref="Org.Apache.Hadoop.FS.FileSystem"/>
	/// without grouping by keys.</p>
	/// <p>Example:</p>
	/// <p><blockquote><pre>
	/// public class MyMapper&lt;K extends WritableComparable, V extends Writable&gt;
	/// extends MapReduceBase implements Mapper&lt;K, V, K, V&gt; {
	/// static enum MyCounters { NUM_RECORDS }
	/// private String mapTaskId;
	/// private String inputFile;
	/// private int noRecords = 0;
	/// public void configure(JobConf job) {
	/// mapTaskId = job.get(JobContext.TASK_ATTEMPT_ID);
	/// inputFile = job.get(JobContext.MAP_INPUT_FILE);
	/// }
	/// public void map(K key, V val,
	/// OutputCollector&lt;K, V&gt; output, Reporter reporter)
	/// throws IOException {
	/// // Process the &lt;key, value&gt; pair (assume this takes a while)
	/// // ...
	/// // ...
	/// // Let the framework know that we are alive, and kicking!
	/// // reporter.progress();
	/// // Process some more
	/// // ...
	/// // ...
	/// // Increment the no. of &lt;key, value&gt; pairs processed
	/// ++noRecords;
	/// // Increment counters
	/// reporter.incrCounter(NUM_RECORDS, 1);
	/// // Every 100 records update application-level status
	/// if ((noRecords%100) == 0) {
	/// reporter.setStatus(mapTaskId + " processed " + noRecords +
	/// " from input-file: " + inputFile);
	/// }
	/// // Output the result
	/// output.collect(key, val);
	/// }
	/// }
	/// </pre></blockquote>
	/// <p>Applications may write a custom
	/// <see cref="MapRunnable{K1, V1, K2, V2}"/>
	/// to exert greater
	/// control on map processing e.g. multi-threaded <code>Mapper</code>s etc.</p>
	/// </remarks>
	/// <seealso cref="JobConf"/>
	/// <seealso cref="InputFormat{K, V}"/>
	/// <seealso cref="Partitioner{K2, V2}"></seealso>
	/// <seealso cref="Reducer{K2, V2, K3, V3}"/>
	/// <seealso cref="MapReduceBase"/>
	/// <seealso cref="MapRunnable{K1, V1, K2, V2}"/>
	/// <seealso cref="Org.Apache.Hadoop.IO.SequenceFile"/>
	public interface Mapper<K1, V1, K2, V2> : JobConfigurable, Closeable
	{
		/// <summary>Maps a single input key/value pair into an intermediate key/value pair.</summary>
		/// <remarks>
		/// Maps a single input key/value pair into an intermediate key/value pair.
		/// <p>Output pairs need not be of the same types as input pairs.  A given
		/// input pair may map to zero or many output pairs.  Output pairs are
		/// collected with calls to
		/// <see cref="OutputCollector{K, V}.Collect(object, object)"/>
		/// .</p>
		/// <p>Applications can use the
		/// <see cref="Reporter"/>
		/// provided to report progress
		/// or just indicate that they are alive. In scenarios where the application
		/// takes significant amount of time to process individual key/value
		/// pairs, this is crucial since the framework might assume that the task has
		/// timed-out and kill that task. The other way of avoiding this is to set
		/// &lt;a href="
		/// <docRoot/>
		/// /../mapred-default.html#mapreduce.task.timeout"&gt;
		/// mapreduce.task.timeout</a> to a high-enough value (or even zero for no
		/// time-outs).</p>
		/// </remarks>
		/// <param name="key">the input key.</param>
		/// <param name="value">the input value.</param>
		/// <param name="output">collects mapped keys and values.</param>
		/// <param name="reporter">facility to report progress.</param>
		/// <exception cref="System.IO.IOException"/>
		void Map(K1 key, V1 value, OutputCollector<K2, V2> output, Reporter reporter);
	}
}
