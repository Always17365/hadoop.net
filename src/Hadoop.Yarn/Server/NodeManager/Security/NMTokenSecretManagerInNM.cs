using System.Collections.Generic;
using System.IO;
using Com.Google.Common.Annotations;
using Org.Apache.Commons.Logging;
using Org.Apache.Hadoop.Classification;
using Org.Apache.Hadoop.Security.Token;
using Org.Apache.Hadoop.Yarn.Api.Records;
using Org.Apache.Hadoop.Yarn.Security;
using Org.Apache.Hadoop.Yarn.Server.Api.Records;
using Org.Apache.Hadoop.Yarn.Server.Nodemanager.Recovery;
using Org.Apache.Hadoop.Yarn.Server.Security;
using Sharpen;

namespace Org.Apache.Hadoop.Yarn.Server.Nodemanager.Security
{
	public class NMTokenSecretManagerInNM : BaseNMTokenSecretManager
	{
		private static readonly Log Log = LogFactory.GetLog(typeof(Org.Apache.Hadoop.Yarn.Server.Nodemanager.Security.NMTokenSecretManagerInNM
			));

		private MasterKeyData previousMasterKey;

		private readonly IDictionary<ApplicationAttemptId, MasterKeyData> oldMasterKeys;

		private readonly IDictionary<ApplicationId, IList<ApplicationAttemptId>> appToAppAttemptMap;

		private readonly NMStateStoreService stateStore;

		private NodeId nodeId;

		public NMTokenSecretManagerInNM()
			: this(new NMNullStateStoreService())
		{
		}

		public NMTokenSecretManagerInNM(NMStateStoreService stateStore)
		{
			this.oldMasterKeys = new Dictionary<ApplicationAttemptId, MasterKeyData>();
			appToAppAttemptMap = new Dictionary<ApplicationId, IList<ApplicationAttemptId>>();
			this.stateStore = stateStore;
		}

		/// <exception cref="System.IO.IOException"/>
		public virtual void Recover()
		{
			lock (this)
			{
				NMStateStoreService.RecoveredNMTokensState state = stateStore.LoadNMTokensState();
				MasterKey key = state.GetCurrentMasterKey();
				if (key != null)
				{
					base.currentMasterKey = new MasterKeyData(key, CreateSecretKey(((byte[])key.GetBytes
						().Array())));
				}
				key = state.GetPreviousMasterKey();
				if (key != null)
				{
					previousMasterKey = new MasterKeyData(key, CreateSecretKey(((byte[])key.GetBytes(
						).Array())));
				}
				// restore the serial number from the current master key
				if (base.currentMasterKey != null)
				{
					base.serialNo = base.currentMasterKey.GetMasterKey().GetKeyId() + 1;
				}
				foreach (KeyValuePair<ApplicationAttemptId, MasterKey> entry in state.GetApplicationMasterKeys
					())
				{
					key = entry.Value;
					oldMasterKeys[entry.Key] = new MasterKeyData(key, CreateSecretKey(((byte[])key.GetBytes
						().Array())));
				}
				// reconstruct app to app attempts map
				appToAppAttemptMap.Clear();
				foreach (ApplicationAttemptId attempt in oldMasterKeys.Keys)
				{
					ApplicationId app = attempt.GetApplicationId();
					IList<ApplicationAttemptId> attempts = appToAppAttemptMap[app];
					if (attempts == null)
					{
						attempts = new AList<ApplicationAttemptId>();
						appToAppAttemptMap[app] = attempts;
					}
					attempts.AddItem(attempt);
				}
			}
		}

		private void UpdateCurrentMasterKey(MasterKeyData key)
		{
			base.currentMasterKey = key;
			try
			{
				stateStore.StoreNMTokenCurrentMasterKey(key.GetMasterKey());
			}
			catch (IOException e)
			{
				Log.Error("Unable to update current master key in state store", e);
			}
		}

		private void UpdatePreviousMasterKey(MasterKeyData key)
		{
			previousMasterKey = key;
			try
			{
				stateStore.StoreNMTokenPreviousMasterKey(key.GetMasterKey());
			}
			catch (IOException e)
			{
				Log.Error("Unable to update previous master key in state store", e);
			}
		}

		/// <summary>
		/// Used by NodeManagers to create a token-secret-manager with the key
		/// obtained from the RM.
		/// </summary>
		/// <remarks>
		/// Used by NodeManagers to create a token-secret-manager with the key
		/// obtained from the RM. This can happen during registration or when the RM
		/// rolls the master-key and signal the NM.
		/// </remarks>
		[InterfaceAudience.Private]
		public virtual void SetMasterKey(MasterKey masterKey)
		{
			lock (this)
			{
				// Update keys only if the key has changed.
				if (base.currentMasterKey == null || base.currentMasterKey.GetMasterKey().GetKeyId
					() != masterKey.GetKeyId())
				{
					Log.Info("Rolling master-key for container-tokens, got key with id " + masterKey.
						GetKeyId());
					if (base.currentMasterKey != null)
					{
						UpdatePreviousMasterKey(base.currentMasterKey);
					}
					UpdateCurrentMasterKey(new MasterKeyData(masterKey, CreateSecretKey(((byte[])masterKey
						.GetBytes().Array()))));
				}
			}
		}

		/// <summary>
		/// This method will be used to verify NMTokens generated by different master
		/// keys.
		/// </summary>
		/// <exception cref="Org.Apache.Hadoop.Security.Token.SecretManager.InvalidToken"/>
		public override byte[] RetrievePassword(NMTokenIdentifier identifier)
		{
			lock (this)
			{
				int keyId = identifier.GetKeyId();
				ApplicationAttemptId appAttemptId = identifier.GetApplicationAttemptId();
				/*
				* MasterKey used for retrieving password will be as follows. 1) By default
				* older saved master key will be used. 2) If identifier's master key id
				* matches that of previous master key id then previous key will be used. 3)
				* If identifier's master key id matches that of current master key id then
				* current key will be used.
				*/
				MasterKeyData oldMasterKey = oldMasterKeys[appAttemptId];
				MasterKeyData masterKeyToUse = oldMasterKey;
				if (previousMasterKey != null && keyId == previousMasterKey.GetMasterKey().GetKeyId
					())
				{
					masterKeyToUse = previousMasterKey;
				}
				else
				{
					if (keyId == currentMasterKey.GetMasterKey().GetKeyId())
					{
						masterKeyToUse = currentMasterKey;
					}
				}
				if (nodeId != null && !identifier.GetNodeId().Equals(nodeId))
				{
					throw new SecretManager.InvalidToken("Given NMToken for application : " + appAttemptId
						.ToString() + " is not valid for current node manager." + "expected : " + nodeId
						.ToString() + " found : " + identifier.GetNodeId().ToString());
				}
				if (masterKeyToUse != null)
				{
					byte[] password = RetrivePasswordInternal(identifier, masterKeyToUse);
					Log.Debug("NMToken password retrieved successfully!!");
					return password;
				}
				throw new SecretManager.InvalidToken("Given NMToken for application : " + appAttemptId
					.ToString() + " seems to have been generated illegally.");
			}
		}

		public virtual void AppFinished(ApplicationId appId)
		{
			lock (this)
			{
				IList<ApplicationAttemptId> appAttemptList = appToAppAttemptMap[appId];
				if (appAttemptList != null)
				{
					Log.Debug("Removing application attempts NMToken keys for application " + appId);
					foreach (ApplicationAttemptId appAttemptId in appAttemptList)
					{
						RemoveAppAttemptKey(appAttemptId);
					}
					Sharpen.Collections.Remove(appToAppAttemptMap, appId);
				}
				else
				{
					Log.Error("No application Attempt for application : " + appId + " started on this NM."
						);
				}
			}
		}

		/// <summary>This will be called by startContainer.</summary>
		/// <remarks>
		/// This will be called by startContainer. It will add the master key into
		/// the cache used for starting this container. This should be called before
		/// validating the startContainer request.
		/// </remarks>
		/// <exception cref="Org.Apache.Hadoop.Security.Token.SecretManager.InvalidToken"/>
		public virtual void AppAttemptStartContainer(NMTokenIdentifier identifier)
		{
			lock (this)
			{
				ApplicationAttemptId appAttemptId = identifier.GetApplicationAttemptId();
				if (!appToAppAttemptMap.Contains(appAttemptId.GetApplicationId()))
				{
					// First application attempt for the given application
					appToAppAttemptMap[appAttemptId.GetApplicationId()] = new AList<ApplicationAttemptId
						>();
				}
				MasterKeyData oldKey = oldMasterKeys[appAttemptId];
				if (oldKey == null)
				{
					// This is a new application attempt.
					appToAppAttemptMap[appAttemptId.GetApplicationId()].AddItem(appAttemptId);
				}
				if (oldKey == null || oldKey.GetMasterKey().GetKeyId() != identifier.GetKeyId())
				{
					// Update key only if it is modified.
					Log.Debug("NMToken key updated for application attempt : " + identifier.GetApplicationAttemptId
						().ToString());
					if (identifier.GetKeyId() == currentMasterKey.GetMasterKey().GetKeyId())
					{
						UpdateAppAttemptKey(appAttemptId, currentMasterKey);
					}
					else
					{
						if (previousMasterKey != null && identifier.GetKeyId() == previousMasterKey.GetMasterKey
							().GetKeyId())
						{
							UpdateAppAttemptKey(appAttemptId, previousMasterKey);
						}
						else
						{
							throw new SecretManager.InvalidToken("Older NMToken should not be used while starting the container."
								);
						}
					}
				}
			}
		}

		public virtual void SetNodeId(NodeId nodeId)
		{
			lock (this)
			{
				Log.Debug("updating nodeId : " + nodeId);
				this.nodeId = nodeId;
			}
		}

		[InterfaceAudience.Private]
		[VisibleForTesting]
		public virtual bool IsAppAttemptNMTokenKeyPresent(ApplicationAttemptId appAttemptId
			)
		{
			lock (this)
			{
				return oldMasterKeys.Contains(appAttemptId);
			}
		}

		[InterfaceAudience.Private]
		[VisibleForTesting]
		public virtual NodeId GetNodeId()
		{
			lock (this)
			{
				return this.nodeId;
			}
		}

		private void UpdateAppAttemptKey(ApplicationAttemptId attempt, MasterKeyData key)
		{
			this.oldMasterKeys[attempt] = key;
			try
			{
				stateStore.StoreNMTokenApplicationMasterKey(attempt, key.GetMasterKey());
			}
			catch (IOException e)
			{
				Log.Error("Unable to store master key for application " + attempt, e);
			}
		}

		private void RemoveAppAttemptKey(ApplicationAttemptId attempt)
		{
			Sharpen.Collections.Remove(this.oldMasterKeys, attempt);
			try
			{
				stateStore.RemoveNMTokenApplicationMasterKey(attempt);
			}
			catch (IOException e)
			{
				Log.Error("Unable to remove master key for application " + attempt, e);
			}
		}
	}
}
