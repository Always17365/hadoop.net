using System;
using System.IO;
using System.Reflection;
using System.Security;
using Com.Google.Protobuf;
using Org.Apache.Hadoop.Ipc;
using Org.Apache.Hadoop.Yarn.Exceptions;
using Sharpen;
using Sharpen.Reflect;

namespace Org.Apache.Hadoop.Yarn.Ipc
{
	public class RPCUtil
	{
		/// <summary>
		/// Returns an instance of
		/// <see cref="Org.Apache.Hadoop.Yarn.Exceptions.YarnException"/>
		/// </summary>
		public static YarnException GetRemoteException(Exception t)
		{
			return new YarnException(t);
		}

		/// <summary>
		/// Returns an instance of
		/// <see cref="Org.Apache.Hadoop.Yarn.Exceptions.YarnException"/>
		/// </summary>
		public static YarnException GetRemoteException(string message)
		{
			return new YarnException(message);
		}

		/// <exception cref="Org.Apache.Hadoop.Ipc.RemoteException"/>
		private static T InstantiateException<T>(Type cls, RemoteException re)
			where T : Exception
		{
			try
			{
				Constructor<T> cn = cls.GetConstructor(typeof(string));
				T ex = cn.NewInstance(re.Message);
				Sharpen.Extensions.InitCause(ex, re);
				return ex;
			}
			catch (MissingMethodException)
			{
				// RemoteException contains useful information as against the
				// java.lang.reflect exceptions.
				throw re;
			}
			catch (ArgumentException)
			{
				throw re;
			}
			catch (SecurityException)
			{
				throw re;
			}
			catch (InstantiationException)
			{
				throw re;
			}
			catch (MemberAccessException)
			{
				throw re;
			}
			catch (TargetInvocationException)
			{
				throw re;
			}
		}

		/// <summary>Utility method that unwraps and returns appropriate exceptions.</summary>
		/// <param name="se">ServiceException</param>
		/// <returns>
		/// An instance of the actual exception, which will be a subclass of
		/// <see cref="Org.Apache.Hadoop.Yarn.Exceptions.YarnException"/>
		/// or
		/// <see cref="System.IO.IOException"/>
		/// </returns>
		/// <exception cref="System.IO.IOException"/>
		/// <exception cref="Org.Apache.Hadoop.Yarn.Exceptions.YarnException"/>
		public static Void UnwrapAndThrowException(ServiceException se)
		{
			Exception cause = se.InnerException;
			if (cause == null)
			{
				// SE generated by the RPC layer itself.
				throw new IOException(se);
			}
			else
			{
				if (cause is RemoteException)
				{
					RemoteException re = (RemoteException)cause;
					Type realClass = null;
					try
					{
						realClass = Sharpen.Runtime.GetType(re.GetClassName());
					}
					catch (TypeLoadException)
					{
						// Assume this to be a new exception type added to YARN. This isn't
						// absolutely correct since the RPC layer could add an exception as
						// well.
						throw InstantiateException(typeof(YarnException), re);
					}
					if (typeof(YarnException).IsAssignableFrom(realClass))
					{
						throw InstantiateException(realClass.AsSubclass<YarnException>(), re);
					}
					else
					{
						if (typeof(IOException).IsAssignableFrom(realClass))
						{
							throw InstantiateException(realClass.AsSubclass<IOException>(), re);
						}
						else
						{
							if (typeof(RuntimeException).IsAssignableFrom(realClass))
							{
								throw InstantiateException(realClass.AsSubclass<RuntimeException>(), re);
							}
							else
							{
								throw re;
							}
						}
					}
				}
				else
				{
					// RemoteException contains useful information as against the
					// java.lang.reflect exceptions.
					if (cause is IOException)
					{
						// RPC Client exception.
						throw (IOException)cause;
					}
					else
					{
						if (cause is RuntimeException)
						{
							// RPC RuntimeException
							throw (RuntimeException)cause;
						}
						else
						{
							// Should not be generated.
							throw new IOException(se);
						}
					}
				}
			}
		}
	}
}
