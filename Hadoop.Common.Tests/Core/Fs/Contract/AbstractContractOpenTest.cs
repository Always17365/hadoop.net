/*
* Licensed to the Apache Software Foundation (ASF) under one
*  or more contributor license agreements.  See the NOTICE file
*  distributed with this work for additional information
*  regarding copyright ownership.  The ASF licenses this file
*  to you under the Apache License, Version 2.0 (the
*  "License"); you may not use this file except in compliance
*  with the License.  You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*/
using System.IO;
using Org.Apache.Hadoop.Conf;
using Org.Apache.Hadoop.FS;
using Org.Apache.Hadoop.IO;


namespace Org.Apache.Hadoop.FS.Contract
{
	/// <summary>Test Seek operations</summary>
	public abstract class AbstractContractOpenTest : AbstractFSContractTestBase
	{
		private FSDataInputStream instream;

		protected internal override Configuration CreateConfiguration()
		{
			Configuration conf = base.CreateConfiguration();
			conf.SetInt(CommonConfigurationKeysPublic.IoFileBufferSizeKey, 4096);
			return conf;
		}

		/// <exception cref="System.Exception"/>
		public override void Teardown()
		{
			IOUtils.CloseStream(instream);
			instream = null;
			base.Teardown();
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestOpenReadZeroByteFile()
		{
			Describe("create & read a 0 byte file");
			Path path = Path("zero.txt");
			ContractTestUtils.Touch(GetFileSystem(), path);
			instream = GetFileSystem().Open(path);
			Assert.Equal(0, instream.GetPos());
			//expect initial read to fail
			int result = instream.Read();
			AssertMinusOne("initial byte read", result);
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestFsIsEncrypted()
		{
			Describe("create an empty file and call FileStatus.isEncrypted()");
			Path path = Path("file");
			ContractTestUtils.CreateFile(GetFileSystem(), path, false, new byte[0]);
			FileStatus stat = GetFileSystem().GetFileStatus(path);
			NUnit.Framework.Assert.IsFalse("Expecting false for stat.isEncrypted()", stat.IsEncrypted
				());
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestOpenReadDir()
		{
			Describe("create & read a directory");
			Path path = Path("zero.dir");
			Mkdirs(path);
			try
			{
				instream = GetFileSystem().Open(path);
				//at this point we've opened a directory
				NUnit.Framework.Assert.Fail("A directory has been opened for reading");
			}
			catch (FileNotFoundException e)
			{
				HandleExpectedException(e);
			}
			catch (IOException e)
			{
				HandleRelaxedException("opening a directory for reading", "FileNotFoundException"
					, e);
			}
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestOpenReadDirWithChild()
		{
			Describe("create & read a directory which has a child");
			Path path = Path("zero.dir");
			Mkdirs(path);
			Path path2 = new Path(path, "child");
			Mkdirs(path2);
			try
			{
				instream = GetFileSystem().Open(path);
				//at this point we've opened a directory
				NUnit.Framework.Assert.Fail("A directory has been opened for reading");
			}
			catch (FileNotFoundException e)
			{
				HandleExpectedException(e);
			}
			catch (IOException e)
			{
				HandleRelaxedException("opening a directory for reading", "FileNotFoundException"
					, e);
			}
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestOpenFileTwice()
		{
			Describe("verify that two opened file streams are independent");
			Path path = Path("testopenfiletwice.txt");
			byte[] block = ContractTestUtils.Dataset(TestFileLen, 0, 255);
			//this file now has a simple rule: offset => value
			ContractTestUtils.CreateFile(GetFileSystem(), path, false, block);
			//open first
			FSDataInputStream instream1 = GetFileSystem().Open(path);
			int c = instream1.Read();
			Assert.Equal(0, c);
			FSDataInputStream instream2 = null;
			try
			{
				instream2 = GetFileSystem().Open(path);
				Assert.Equal("first read of instream 2", 0, instream2.Read());
				Assert.Equal("second read of instream 1", 1, instream1.Read());
				instream1.Close();
				Assert.Equal("second read of instream 2", 1, instream2.Read());
				//close instream1 again
				instream1.Close();
			}
			finally
			{
				IOUtils.CloseStream(instream1);
				IOUtils.CloseStream(instream2);
			}
		}

		/// <exception cref="System.Exception"/>
		[Fact]
		public virtual void TestSequentialRead()
		{
			Describe("verify that sequential read() operations return values");
			Path path = Path("testsequentialread.txt");
			int len = 4;
			int @base = unchecked((int)(0x40));
			// 64
			byte[] block = ContractTestUtils.Dataset(len, @base, @base + len);
			//this file now has a simple rule: offset => (value | 0x40)
			ContractTestUtils.CreateFile(GetFileSystem(), path, false, block);
			//open first
			instream = GetFileSystem().Open(path);
			Assert.Equal(@base, instream.Read());
			Assert.Equal(@base + 1, instream.Read());
			Assert.Equal(@base + 2, instream.Read());
			Assert.Equal(@base + 3, instream.Read());
			// and now, failures
			Assert.Equal(-1, instream.Read());
			Assert.Equal(-1, instream.Read());
			instream.Close();
		}
	}
}
