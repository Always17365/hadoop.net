using System;
using System.IO;
using System.Net;
using Com.Google.Common.Base;
using Org.Apache.Commons.Logging;
using Org.Apache.Hadoop.Conf;
using Org.Apache.Hadoop.FS;
using Org.Apache.Hadoop.IO;
using Org.Apache.Hadoop.Util;
using Sharpen;

namespace Org.Apache.Hadoop.FS.LoadGenerator
{
	/// <summary>
	/// The load generator is a tool for testing NameNode behavior under
	/// different client loads.
	/// </summary>
	/// <remarks>
	/// The load generator is a tool for testing NameNode behavior under
	/// different client loads. Note there is a subclass of this clas that lets
	/// you run a the load generator as a MapReduce job (see LoadGeneratorMR in the
	/// MapReduce project.
	/// The loadGenerator allows the user to generate different mixes of read, write,
	/// and list requests by specifying the probabilities of read and
	/// write. The user controls the intensity of the load by
	/// adjusting parameters for the number of worker threads and the delay
	/// between operations. While load generators are running, the user
	/// can profile and monitor the running of the NameNode. When a load
	/// generator exits, it print some NameNode statistics like the average
	/// execution time of each kind of operations and the NameNode
	/// throughput.
	/// The program can run in one of two forms. As a regular single process command
	/// that runs multiple threads to generate load on the NN or as a Map Reduce
	/// program that runs multiple (multi-threaded) map tasks that generate load
	/// on the NN; the results summary is generated by a single reduce task.
	/// The user may either specify constant duration, read and write
	/// probabilities via the command line, or may specify a text file
	/// that acts as a script of which read and write probabilities to
	/// use for specified durations. If no duration is specified the program
	/// runs till killed (duration required if run as MapReduce).
	/// The script takes the form of lines of duration in seconds, read
	/// probability and write probability, each separated by white space.
	/// Blank lines and lines starting with # (comments) are ignored. If load
	/// generator is run as a MapReduce program then the script file needs to be
	/// accessible on the the Map task as a HDFS file.
	/// After command line argument parsing and data initialization,
	/// the load generator spawns the number of worker threads
	/// as specified by the user.
	/// Each thread sends a stream of requests to the NameNode.
	/// For each iteration, it first decides if it is going to read a file,
	/// create a file, or listing a directory following the read and write
	/// probabilities specified by the user.
	/// When reading, it randomly picks a file in the test space and reads
	/// the entire file. When writing, it randomly picks a directory in the
	/// test space and creates a file whose name consists of the current
	/// machine's host name and the thread id. The length of the file
	/// follows Gaussian distribution with an average size of 2 blocks and
	/// the standard deviation of 1 block. The new file is filled with 'a'.
	/// Immediately after the file creation completes, the file is deleted
	/// from the test space.
	/// While listing, it randomly picks a directory in the test space and
	/// list the directory content.
	/// Between two consecutive operations, the thread pauses for a random
	/// amount of time in the range of [0, maxDelayBetweenOps]
	/// if the specified max delay is not zero.
	/// All threads are stopped when the specified elapsed time has passed
	/// in command-line execution, or all the lines of script have been
	/// executed, if using a script.
	/// Before exiting, the program prints the average execution for
	/// each kind of NameNode operations, and the number of requests
	/// served by the NameNode.
	/// The synopsis of the command is
	/// java LoadGenerator
	/// -readProbability <read probability>: read probability [0, 1]
	/// with a default value of 0.3333.
	/// -writeProbability <write probability>: write probability [0, 1]
	/// with a default value of 0.3333.
	/// -root <root>: test space with a default value of /testLoadSpace
	/// -maxDelayBetweenOps <maxDelayBetweenOpsInMillis>:
	/// Max delay in the unit of milliseconds between two operations with a
	/// default value of 0 indicating no delay.
	/// -numOfThreads <numOfThreads>:
	/// number of threads to spawn with a default value of 200.
	/// -elapsedTime <elapsedTimeInSecs>:
	/// the elapsed time of program with a default value of 0
	/// indicating running forever
	/// -startTime <startTimeInMillis> : when the threads start to run.
	/// -scriptFile <file name>: text file to parse for scripted operation
	/// </remarks>
	public class LoadGenerator : Configured, Tool
	{
		public static readonly Log Log = LogFactory.GetLog(typeof(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
			));

		private static volatile bool shouldRun = true;

		protected internal static Path root = DataGenerator.DefaultRoot;

		private static FileContext fc;

		protected internal static int maxDelayBetweenOps = 0;

		protected internal static int numOfThreads = 200;

		protected internal static long[] durations = new long[] { 0 };

		protected internal static double[] readProbs = new double[] { 0.3333 };

		protected internal static double[] writeProbs = new double[] { 0.3333 };

		private static volatile int currentIndex = 0;

		protected internal static long totalTime = 0;

		protected internal static long startTime = Time.Now() + 10000;

		private const int BlockSize = 10;

		private static AList<string> files = new AList<string>();

		private static AList<string> dirs = new AList<string>();

		protected internal static Random r = null;

		protected internal static long seed = 0;

		protected internal static string scriptFile = null;

		protected internal const string FlagfileDefault = "/tmp/flagFile";

		protected internal static Path flagFile = new Path(FlagfileDefault);

		protected internal string hostname;

		private const string UsageCmd = "java LoadGenerator\n";

		protected internal const string UsageArgs = "-readProbability <read probability>\n"
			 + "-writeProbability <write probability>\n" + "-root <root>\n" + "-maxDelayBetweenOps <maxDelayBetweenOpsInMillis>\n"
			 + "-numOfThreads <numOfThreads>\n" + "-elapsedTime <elapsedTimeInSecs>\n" + "-startTime <startTimeInMillis>\n"
			 + "-scriptFile <filename>\n" + "-flagFile <filename>";

		private const string Usage = UsageCmd + UsageArgs;

		private readonly byte[] WriteContents = new byte[4096];

		private const int ErrTestFailed = 2;

		/// <summary>Constructor</summary>
		/// <exception cref="System.IO.IOException"/>
		/// <exception cref="Sharpen.UnknownHostException"/>
		public LoadGenerator()
		{
			// a table of file names
			// a table of directory names
			IPAddress addr = Sharpen.Runtime.GetLocalHost();
			hostname = addr.GetHostName();
			Arrays.Fill(WriteContents, unchecked((byte)'a'));
		}

		/// <exception cref="System.IO.IOException"/>
		/// <exception cref="Sharpen.UnknownHostException"/>
		public LoadGenerator(Configuration conf)
			: this()
		{
			SetConf(conf);
		}

		protected internal const int Open = 0;

		protected internal const int List = 1;

		protected internal const int Create = 2;

		protected internal const int WriteClose = 3;

		protected internal const int Delete = 4;

		protected internal const int TotalOpTypes = 5;

		protected internal static long[] executionTime = new long[TotalOpTypes];

		protected internal static long[] numOfOps = new long[TotalOpTypes];

		protected internal static long totalOps = 0;

		/// <summary>A thread sends a stream of requests to the NameNode.</summary>
		/// <remarks>
		/// A thread sends a stream of requests to the NameNode.
		/// At each iteration, it first decides if it is going to read a file,
		/// create a file, or listing a directory following the read
		/// and write probabilities.
		/// When reading, it randomly picks a file in the test space and reads
		/// the entire file. When writing, it randomly picks a directory in the
		/// test space and creates a file whose name consists of the current
		/// machine's host name and the thread id. The length of the file
		/// follows Gaussian distribution with an average size of 2 blocks and
		/// the standard deviation of 1 block. The new file is filled with 'a'.
		/// Immediately after the file creation completes, the file is deleted
		/// from the test space.
		/// While listing, it randomly picks a directory in the test space and
		/// list the directory content.
		/// Between two consecutive operations, the thread pauses for a random
		/// amount of time in the range of [0, maxDelayBetweenOps]
		/// if the specified max delay is not zero.
		/// A thread runs for the specified elapsed time if the time isn't zero.
		/// Otherwise, it runs forever.
		/// </remarks>
		private class DFSClientThread : Sharpen.Thread
		{
			private int id;

			private long[] executionTime = new long[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
				.TotalOpTypes];

			private long[] totalNumOfOps = new long[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
				.TotalOpTypes];

			private byte[] buffer = new byte[1024];

			private bool failed;

			private DFSClientThread(LoadGenerator _enclosing, int id)
			{
				this._enclosing = _enclosing;
				// across all of types
				this.id = id;
			}

			/// <summary>
			/// Main loop for each thread
			/// Each iteration decides what's the next operation and then pauses.
			/// </summary>
			public override void Run()
			{
				try
				{
					while (Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.shouldRun)
					{
						this.NextOp();
						this.Delay();
					}
				}
				catch (Exception ioe)
				{
					System.Console.Error.WriteLine(ioe.GetLocalizedMessage());
					Sharpen.Runtime.PrintStackTrace(ioe);
					this.failed = true;
				}
			}

			/// <summary>
			/// Let the thread pause for a random amount of time in the range of
			/// [0, maxDelayBetweenOps] if the delay is not zero.
			/// </summary>
			/// <remarks>
			/// Let the thread pause for a random amount of time in the range of
			/// [0, maxDelayBetweenOps] if the delay is not zero. Otherwise, no pause.
			/// </remarks>
			/// <exception cref="System.Exception"/>
			private void Delay()
			{
				if (Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.maxDelayBetweenOps > 0)
				{
					int delay = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.r.Next(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
						.maxDelayBetweenOps);
					Sharpen.Thread.Sleep(delay);
				}
			}

			/// <summary>Perform the next operation.</summary>
			/// <remarks>
			/// Perform the next operation.
			/// Depending on the read and write probabilities, the next
			/// operation could be either read, write, or list.
			/// </remarks>
			/// <exception cref="System.IO.IOException"/>
			private void NextOp()
			{
				double rn = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.r.NextDouble();
				int i = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.currentIndex;
				if (Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Log.IsDebugEnabled())
				{
					Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Log.Debug("Thread " + this.id + 
						" moving to index " + i);
				}
				if (rn < Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.readProbs[i])
				{
					this.Read();
				}
				else
				{
					if (rn < Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.readProbs[i] + Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
						.writeProbs[i])
					{
						this.Write();
					}
					else
					{
						this.List();
					}
				}
			}

			/// <summary>
			/// Read operation randomly picks a file in the test space and reads
			/// the entire file
			/// </summary>
			/// <exception cref="System.IO.IOException"/>
			private void Read()
			{
				string fileName = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.files[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
					.r.Next(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.files.Count)];
				long startTime = Time.Now();
				InputStream @in = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.fc.Open(new Path
					(fileName));
				this.executionTime[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Open] += (Time
					.Now() - startTime);
				this.totalNumOfOps[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Open]++;
				while (@in.Read(this.buffer) != -1)
				{
				}
				@in.Close();
			}

			/// <summary>
			/// The write operation randomly picks a directory in the
			/// test space and creates a file whose name consists of the current
			/// machine's host name and the thread id.
			/// </summary>
			/// <remarks>
			/// The write operation randomly picks a directory in the
			/// test space and creates a file whose name consists of the current
			/// machine's host name and the thread id. The length of the file
			/// follows Gaussian distribution with an average size of 2 blocks and
			/// the standard deviation of 1 block. The new file is filled with 'a'.
			/// Immediately after the file creation completes, the file is deleted
			/// from the test space.
			/// </remarks>
			/// <exception cref="System.IO.IOException"/>
			private void Write()
			{
				string dirName = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.dirs[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
					.r.Next(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.dirs.Count)];
				Path file = new Path(dirName, this._enclosing.hostname + this.id);
				double fileSize = 0;
				while ((fileSize = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.r.NextGaussian
					() + 2) <= 0)
				{
				}
				this.GenFile(file, (long)(fileSize * Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
					.BlockSize));
				long startTime = Time.Now();
				Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.fc.Delete(file, true);
				this.executionTime[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Delete] += (Time
					.Now() - startTime);
				this.totalNumOfOps[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Delete]++;
			}

			/// <summary>
			/// The list operation randomly picks a directory in the test space and
			/// list the directory content.
			/// </summary>
			/// <exception cref="System.IO.IOException"/>
			private void List()
			{
				string dirName = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.dirs[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
					.r.Next(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.dirs.Count)];
				long startTime = Time.Now();
				Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.fc.ListStatus(new Path(dirName));
				this.executionTime[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.List] += (Time
					.Now() - startTime);
				this.totalNumOfOps[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.List]++;
			}

			/// <summary>Create a file with a length of <code>fileSize</code>.</summary>
			/// <remarks>
			/// Create a file with a length of <code>fileSize</code>.
			/// The file is filled with 'a'.
			/// </remarks>
			/// <exception cref="System.IO.IOException"/>
			private void GenFile(Path file, long fileSize)
			{
				long startTime = Time.Now();
				FSDataOutputStream @out = null;
				try
				{
					@out = Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.fc.Create(file, EnumSet.Of
						(CreateFlag.Create, CreateFlag.Overwrite), Options.CreateOpts.CreateParent(), Options.CreateOpts
						.BufferSize(4096), Options.CreateOpts.RepFac((short)3));
					this.executionTime[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Create] += (Time
						.Now() - startTime);
					Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.numOfOps[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
						.Create]++;
					long i = fileSize;
					while (i > 0)
					{
						long s = Math.Min(fileSize, this._enclosing.WriteContents.Length);
						@out.Write(this._enclosing.WriteContents, 0, (int)s);
						i -= s;
					}
					startTime = Time.Now();
					this.executionTime[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.WriteClose] +=
						 (Time.Now() - startTime);
					Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.numOfOps[Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
						.WriteClose]++;
				}
				finally
				{
					IOUtils.Cleanup(Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator.Log, @out);
				}
			}

			private readonly LoadGenerator _enclosing;
		}

		/// <summary>Main function called by tool runner.</summary>
		/// <remarks>
		/// Main function called by tool runner.
		/// It first initializes data by parsing the command line arguments.
		/// It then calls the loadGenerator
		/// </remarks>
		/// <exception cref="System.Exception"/>
		public virtual int Run(string[] args)
		{
			int exitCode = ParseArgs(false, args);
			if (exitCode != 0)
			{
				return exitCode;
			}
			System.Console.Out.WriteLine("Running LoadGenerator against fileSystem: " + FileContext
				.GetFileContext().GetDefaultFileSystem().GetUri());
			exitCode = GenerateLoadOnNN();
			PrintResults(System.Console.Out);
			return exitCode;
		}

		internal virtual bool StopFileCreated()
		{
			try
			{
				fc.GetFileStatus(flagFile);
			}
			catch (FileNotFoundException)
			{
				return false;
			}
			catch (IOException e)
			{
				Log.Error("Got error when checking if file exists:" + flagFile, e);
			}
			Log.Info("Flag file was created. Stopping the test.");
			return true;
		}

		/// <summary>
		/// This is the main function - run threads to generate load on NN
		/// It starts the number of DFSClient threads as specified by
		/// the user.
		/// </summary>
		/// <remarks>
		/// This is the main function - run threads to generate load on NN
		/// It starts the number of DFSClient threads as specified by
		/// the user.
		/// It stops all the threads when the specified elapsed time is passed.
		/// </remarks>
		/// <exception cref="System.Exception"/>
		protected internal virtual int GenerateLoadOnNN()
		{
			int hostHashCode = hostname.GetHashCode();
			if (seed == 0)
			{
				r = new Random(Runtime.CurrentTimeMillis() + hostHashCode);
			}
			else
			{
				r = new Random(seed + hostHashCode);
			}
			try
			{
				fc = FileContext.GetFileContext(GetConf());
			}
			catch (IOException ioe)
			{
				System.Console.Error.WriteLine("Can not initialize the file system: " + ioe.GetLocalizedMessage
					());
				return -1;
			}
			int status = InitFileDirTables();
			if (status != 0)
			{
				return status;
			}
			Barrier();
			LoadGenerator.DFSClientThread[] threads = new LoadGenerator.DFSClientThread[numOfThreads
				];
			for (int i = 0; i < numOfThreads; i++)
			{
				threads[i] = new LoadGenerator.DFSClientThread(this, i);
				threads[i].Start();
			}
			if (durations[0] > 0)
			{
				if (durations.Length == 1)
				{
					// There is a fixed run time
					while (shouldRun)
					{
						Sharpen.Thread.Sleep(2000);
						totalTime += 2;
						if (totalTime >= durations[0] || StopFileCreated())
						{
							shouldRun = false;
						}
					}
				}
				else
				{
					// script run
					while (shouldRun)
					{
						Sharpen.Thread.Sleep(durations[currentIndex] * 1000);
						totalTime += durations[currentIndex];
						// Are we on the final line of the script?
						if ((currentIndex + 1) == durations.Length || StopFileCreated())
						{
							shouldRun = false;
						}
						else
						{
							if (Log.IsDebugEnabled())
							{
								Log.Debug("Moving to index " + currentIndex + ": r = " + readProbs[currentIndex] 
									+ ", w = " + writeProbs + " for duration " + durations[currentIndex]);
							}
							currentIndex++;
						}
					}
				}
			}
			if (Log.IsDebugEnabled())
			{
				Log.Debug("Done with testing.  Waiting for threads to finish.");
			}
			bool failed = false;
			foreach (LoadGenerator.DFSClientThread thread in threads)
			{
				thread.Join();
				for (int i_1 = 0; i_1 < TotalOpTypes; i_1++)
				{
					executionTime[i_1] += thread.executionTime[i_1];
					numOfOps[i_1] += thread.totalNumOfOps[i_1];
				}
				failed = failed || thread.failed;
			}
			int exitCode = 0;
			if (failed)
			{
				exitCode = -ErrTestFailed;
			}
			totalOps = 0;
			for (int i_2 = 0; i_2 < TotalOpTypes; i_2++)
			{
				totalOps += numOfOps[i_2];
			}
			return exitCode;
		}

		/// <exception cref="Org.Apache.Hadoop.FS.UnsupportedFileSystemException"/>
		protected internal static void PrintResults(TextWriter @out)
		{
			@out.WriteLine("Result of running LoadGenerator against fileSystem: " + FileContext
				.GetFileContext().GetDefaultFileSystem().GetUri());
			if (numOfOps[Open] != 0)
			{
				@out.WriteLine("Average open execution time: " + (double)executionTime[Open] / numOfOps
					[Open] + "ms");
			}
			if (numOfOps[List] != 0)
			{
				@out.WriteLine("Average list execution time: " + (double)executionTime[List] / numOfOps
					[List] + "ms");
			}
			if (numOfOps[Delete] != 0)
			{
				@out.WriteLine("Average deletion execution time: " + (double)executionTime[Delete
					] / numOfOps[Delete] + "ms");
				@out.WriteLine("Average create execution time: " + (double)executionTime[Create] 
					/ numOfOps[Create] + "ms");
				@out.WriteLine("Average write_close execution time: " + (double)executionTime[WriteClose
					] / numOfOps[WriteClose] + "ms");
			}
			if (totalTime != 0)
			{
				@out.WriteLine("Average operations per second: " + (double)totalOps / totalTime +
					 "ops/s");
			}
			@out.WriteLine();
		}

		/// <summary>Parse the command line arguments and initialize the data</summary>
		/// <exception cref="System.IO.IOException"/>
		protected internal virtual int ParseArgs(bool runAsMapReduce, string[] args)
		{
			try
			{
				for (int i = 0; i < args.Length; i++)
				{
					// parse command line
					if (args[i].Equals("-scriptFile"))
					{
						scriptFile = args[++i];
						if (durations[0] > 0)
						{
							System.Console.Error.WriteLine("Can't specify elapsedTime and use script.");
							return -1;
						}
					}
					else
					{
						if (args[i].Equals("-readProbability"))
						{
							if (scriptFile != null)
							{
								System.Console.Error.WriteLine("Can't specify probabilities and use script.");
								return -1;
							}
							readProbs[0] = double.ParseDouble(args[++i]);
							if (readProbs[0] < 0 || readProbs[0] > 1)
							{
								System.Console.Error.WriteLine("The read probability must be [0, 1]: " + readProbs
									[0]);
								return -1;
							}
						}
						else
						{
							if (args[i].Equals("-writeProbability"))
							{
								if (scriptFile != null)
								{
									System.Console.Error.WriteLine("Can't specify probabilities and use script.");
									return -1;
								}
								writeProbs[0] = double.ParseDouble(args[++i]);
								if (writeProbs[0] < 0 || writeProbs[0] > 1)
								{
									System.Console.Error.WriteLine("The write probability must be [0, 1]: " + writeProbs
										[0]);
									return -1;
								}
							}
							else
							{
								if (args[i].Equals("-root"))
								{
									root = new Path(args[++i]);
								}
								else
								{
									if (args[i].Equals("-maxDelayBetweenOps"))
									{
										maxDelayBetweenOps = System.Convert.ToInt32(args[++i]);
									}
									else
									{
										// in milliseconds
										if (args[i].Equals("-numOfThreads"))
										{
											numOfThreads = System.Convert.ToInt32(args[++i]);
											if (numOfThreads <= 0)
											{
												System.Console.Error.WriteLine("Number of threads must be positive: " + numOfThreads
													);
												return -1;
											}
										}
										else
										{
											if (args[i].Equals("-startTime"))
											{
												startTime = long.Parse(args[++i]);
											}
											else
											{
												if (args[i].Equals("-elapsedTime"))
												{
													if (scriptFile != null)
													{
														System.Console.Error.WriteLine("Can't specify elapsedTime and use script.");
														return -1;
													}
													durations[0] = long.Parse(args[++i]);
												}
												else
												{
													if (args[i].Equals("-seed"))
													{
														seed = long.Parse(args[++i]);
														r = new Random(seed);
													}
													else
													{
														if (args[i].Equals("-flagFile"))
														{
															Log.Info("got flagFile:" + flagFile);
															flagFile = new Path(args[++i]);
														}
														else
														{
															System.Console.Error.WriteLine(Usage);
															ToolRunner.PrintGenericCommandUsage(System.Console.Error);
															return -1;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			catch (FormatException e)
			{
				System.Console.Error.WriteLine("Illegal parameter: " + e.GetLocalizedMessage());
				System.Console.Error.WriteLine(Usage);
				return -1;
			}
			// Load Script File if not MR; for MR scriptFile is loaded by Mapper
			if (!runAsMapReduce && scriptFile != null)
			{
				if (LoadScriptFile(scriptFile, true) == -1)
				{
					return -1;
				}
			}
			for (int i_1 = 0; i_1 < readProbs.Length; i_1++)
			{
				if (readProbs[i_1] + writeProbs[i_1] < 0 || readProbs[i_1] + writeProbs[i_1] > 1)
				{
					System.Console.Error.WriteLine("The sum of read probability and write probability must be [0, 1]: "
						 + readProbs[i_1] + " " + writeProbs[i_1]);
					return -1;
				}
			}
			return 0;
		}

		private static void ParseScriptLine(string line, AList<long> duration, AList<double
			> readProb, AList<double> writeProb)
		{
			string[] a = line.Split("\\s");
			if (a.Length != 3)
			{
				throw new ArgumentException("Incorrect number of parameters: " + line);
			}
			try
			{
				long d = long.Parse(a[0]);
				double r = double.ParseDouble(a[1]);
				double w = double.ParseDouble(a[2]);
				Preconditions.CheckArgument(d >= 0, "Invalid duration: " + d);
				Preconditions.CheckArgument(0 <= r && r <= 1.0, "The read probability must be [0, 1]: "
					 + r);
				Preconditions.CheckArgument(0 <= w && w <= 1.0, "The read probability must be [0, 1]: "
					 + w);
				readProb.AddItem(r);
				duration.AddItem(d);
				writeProb.AddItem(w);
			}
			catch (FormatException)
			{
				throw new ArgumentException("Cannot parse: " + line);
			}
		}

		/// <summary>
		/// Read a script file of the form: lines of text with duration in seconds,
		/// read probability and write probability, separated by white space.
		/// </summary>
		/// <param name="filename">Script file</param>
		/// <returns>0 if successful, -1 if not</returns>
		/// <exception cref="System.IO.IOException">if errors with file IO</exception>
		protected internal static int LoadScriptFile(string filename, bool readLocally)
		{
			FileContext fc;
			if (readLocally)
			{
				// read locally - program is run without MR
				fc = FileContext.GetLocalFSFileContext();
			}
			else
			{
				fc = FileContext.GetFileContext();
			}
			// use default file system
			DataInputStream @in = null;
			try
			{
				@in = fc.Open(new Path(filename));
			}
			catch (IOException)
			{
				System.Console.Error.WriteLine("Unable to open scriptFile: " + filename);
				System.Environment.Exit(-1);
			}
			InputStreamReader inr = new InputStreamReader(@in);
			BufferedReader br = new BufferedReader(inr);
			AList<long> duration = new AList<long>();
			AList<double> readProb = new AList<double>();
			AList<double> writeProb = new AList<double>();
			int lineNum = 0;
			string line;
			// Read script, parse values, build array of duration, read and write probs
			try
			{
				while ((line = br.ReadLine()) != null)
				{
					lineNum++;
					if (line.StartsWith("#") || line.IsEmpty())
					{
						// skip comments and blanks
						continue;
					}
					ParseScriptLine(line, duration, readProb, writeProb);
				}
			}
			catch (ArgumentException e)
			{
				System.Console.Error.WriteLine("Line: " + lineNum + ", " + e.Message);
				return -1;
			}
			finally
			{
				IOUtils.Cleanup(Log, br);
			}
			// Copy vectors to arrays of values, to avoid autoboxing overhead later
			durations = new long[duration.Count];
			readProbs = new double[readProb.Count];
			writeProbs = new double[writeProb.Count];
			for (int i = 0; i < durations.Length; i++)
			{
				durations[i] = duration[i];
				readProbs[i] = readProb[i];
				writeProbs[i] = writeProb[i];
			}
			if (durations[0] == 0)
			{
				System.Console.Error.WriteLine("Initial duration set to 0.  " + "Will loop until stopped manually."
					);
			}
			return 0;
		}

		/// <summary>
		/// Create a table that contains all directories under root and
		/// another table that contains all files under root.
		/// </summary>
		private int InitFileDirTables()
		{
			try
			{
				InitFileDirTables(root);
			}
			catch (IOException e)
			{
				System.Console.Error.WriteLine(e.GetLocalizedMessage());
				Sharpen.Runtime.PrintStackTrace(e);
				return -1;
			}
			if (dirs.IsEmpty())
			{
				System.Console.Error.WriteLine("The test space " + root + " is empty");
				return -1;
			}
			if (files.IsEmpty())
			{
				System.Console.Error.WriteLine("The test space " + root + " does not have any file"
					);
				return -1;
			}
			return 0;
		}

		/// <summary>
		/// Create a table that contains all directories under the specified path and
		/// another table that contains all files under the specified path and
		/// whose name starts with "_file_".
		/// </summary>
		/// <exception cref="System.IO.IOException"/>
		private void InitFileDirTables(Path path)
		{
			FileStatus[] stats = fc.Util().ListStatus(path);
			foreach (FileStatus stat in stats)
			{
				if (stat.IsDirectory())
				{
					dirs.AddItem(stat.GetPath().ToString());
					InitFileDirTables(stat.GetPath());
				}
				else
				{
					Path filePath = stat.GetPath();
					if (filePath.GetName().StartsWith(StructureGenerator.FileNamePrefix))
					{
						files.AddItem(filePath.ToString());
					}
				}
			}
		}

		/// <summary>
		/// Returns when the current number of seconds from the epoch equals
		/// the command line argument given by <code>-startTime</code>.
		/// </summary>
		/// <remarks>
		/// Returns when the current number of seconds from the epoch equals
		/// the command line argument given by <code>-startTime</code>.
		/// This allows multiple instances of this program, running on clock
		/// synchronized nodes, to start at roughly the same time.
		/// </remarks>
		private static void Barrier()
		{
			long sleepTime;
			while ((sleepTime = startTime - Time.Now()) > 0)
			{
				try
				{
					Sharpen.Thread.Sleep(sleepTime);
				}
				catch (Exception)
				{
				}
			}
		}

		/// <summary>Main program</summary>
		/// <param name="args">command line arguments</param>
		/// <exception cref="System.Exception"/>
		public static void Main(string[] args)
		{
			int res = ToolRunner.Run(new Configuration(), new Org.Apache.Hadoop.FS.LoadGenerator.LoadGenerator
				(), args);
			System.Environment.Exit(res);
		}
	}
}
