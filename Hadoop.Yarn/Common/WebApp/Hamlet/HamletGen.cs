using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using Com.Google.Common.Collect;
using Org.Apache.Commons.Cli;
using Org.Apache.Hadoop.Util;
using Org.Apache.Hadoop.Yarn.Webapp;
using Org.Slf4j;
using Sharpen;
using Sharpen.Reflect;

namespace Org.Apache.Hadoop.Yarn.Webapp.Hamlet
{
	/// <summary>
	/// Generates a specific hamlet implementation class from a spec class
	/// using a generic hamlet implementation class.
	/// </summary>
	public class HamletGen
	{
		internal static readonly Logger Log = LoggerFactory.GetLogger(typeof(HamletGen));

		internal static readonly Options opts = new Options();

		static HamletGen()
		{
			opts.AddOption("h", "help", false, "Print this help message").AddOption("s", "spec-class"
				, true, "The class that holds the spec interfaces. e.g. HamletSpec").AddOption("i"
				, "impl-class", true, "An implementation class. e.g. HamletImpl").AddOption("o", 
				"output-class", true, "Output class name").AddOption("p", "output-package", true
				, "Output package name");
		}

		internal static readonly Sharpen.Pattern elementRegex = Sharpen.Pattern.Compile("^[A-Z][A-Z0-9]*$"
			);

		internal int bytes = 0;

		internal PrintWriter @out;

		internal readonly ICollection<string> endTagOptional = Sets.NewHashSet();

		internal readonly ICollection<string> inlineElements = Sets.NewHashSet();

		internal Type top;

		internal string hamlet;

		internal bool topMode;

		// html top-level interface
		// output class simple name;
		/// <summary>Generate a specific Hamlet implementation from a spec.</summary>
		/// <param name="specClass">
		/// holds hamlet interfaces. e.g.
		/// <see cref="HamletSpec"/>
		/// </param>
		/// <param name="implClass">
		/// a generic hamlet implementation. e.g.
		/// <see cref="HamletImpl"/>
		/// </param>
		/// <param name="outputName">
		/// name of the output class. e.g.
		/// <see cref="Hamlet"/>
		/// </param>
		/// <param name="outputPkg">package name of the output class.</param>
		/// <exception cref="System.IO.IOException"/>
		public virtual void Generate(Type specClass, Type implClass, string outputName, string
			 outputPkg)
		{
			Log.Info("Generating {} using {} and {}", new object[] { outputName, specClass, implClass
				 });
			@out = new PrintWriter(outputName + ".java", "UTF-8");
			hamlet = Basename(outputName);
			string pkg = PkgName(outputPkg, implClass.Assembly.GetName());
			Puts(0, "// Generated by HamletGen. Do NOT edit!\n", "package ", pkg, ";\n", "import java.io.PrintWriter;\n"
				, "import java.util.EnumSet;\n", "import static java.util.EnumSet.*;\n", "import static "
				, implClass.FullName, ".EOpt.*;\n", "import org.apache.hadoop.yarn.webapp.SubView;"
				);
			string implClassName = implClass.Name;
			if (!implClass.Assembly.GetName().Equals(pkg))
			{
				Puts(0, "import ", implClass.FullName, ';');
			}
			Puts(0, "\n", "public class ", hamlet, " extends ", implClassName, " implements "
				, specClass.Name, "._Html {\n", "  public ", hamlet, "(PrintWriter out, int nestLevel,"
				, " boolean wasInline) {\n", "    super(out, nestLevel, wasInline);\n", "  }\n\n"
				, "  static EnumSet<EOpt> opt(boolean endTag, boolean inline, ", "boolean pre) {\n"
				, "    EnumSet<EOpt> opts = of(ENDTAG);\n", "    if (!endTag) opts.remove(ENDTAG);\n"
				, "    if (inline) opts.add(INLINE);\n", "    if (pre) opts.add(PRE);\n", "    return opts;\n"
				, "  }");
			// inline is context sensitive
			InitLut(specClass);
			GenImpl(specClass, implClassName, 1);
			Log.Info("Generating {} methods", hamlet);
			GenMethods(hamlet, top, 1);
			Puts(0, "}");
			@out.Close();
			Log.Info("Wrote {} bytes to {}.java", bytes, outputName);
		}

		internal virtual string Basename(string path)
		{
			return Sharpen.Runtime.Substring(path, path.LastIndexOf('/') + 1);
		}

		internal virtual string PkgName(string pkg, string defaultPkg)
		{
			if (pkg == null || pkg.IsEmpty())
			{
				return defaultPkg;
			}
			return pkg;
		}

		internal virtual void InitLut(Type spec)
		{
			endTagOptional.Clear();
			inlineElements.Clear();
			foreach (Type cls in spec.GetClasses())
			{
				Sharpen.Annotation.Annotation a = cls.GetAnnotation<HamletSpec.Element>();
				if (a != null && !((HamletSpec.Element)a).EndTag())
				{
					endTagOptional.AddItem(cls.Name);
				}
				if (cls.Name.Equals("Inline"))
				{
					foreach (MethodInfo method in cls.GetMethods())
					{
						string retName = method.ReturnType.Name;
						if (IsElement(retName))
						{
							inlineElements.AddItem(retName);
						}
					}
				}
			}
		}

		internal virtual void GenImpl(Type spec, string implClassName, int indent)
		{
			string specName = spec.Name;
			foreach (Type cls in spec.GetClasses())
			{
				string className = cls.Name;
				if (cls.IsInterface)
				{
					GenFactoryMethods(cls, indent);
				}
				if (IsElement(className))
				{
					Log.Info("Generating class {}<T>", className);
					Puts(indent, "\n", "public class ", className, "<T extends _>", " extends EImp<T> implements "
						, specName, ".", className, " {\n", "  public ", className, "(String name, T parent,"
						, " EnumSet<EOpt> opts) {\n", "    super(name, parent, opts);\n", "  }");
					GenMethods(className, cls, indent + 1);
					Puts(indent, "}");
				}
				else
				{
					if (className.Equals("_Html"))
					{
						top = cls;
					}
				}
			}
		}

		internal virtual void GenFactoryMethods(Type cls, int indent)
		{
			foreach (MethodInfo method in Sharpen.Runtime.GetDeclaredMethods(cls))
			{
				string retName = method.ReturnType.Name;
				string methodName = method.Name;
				if (methodName[0] == '$')
				{
					continue;
				}
				if (IsElement(retName) && Sharpen.Runtime.GetParameterTypes(method).Length == 0)
				{
					GenFactoryMethod(retName, methodName, indent);
				}
			}
		}

		internal virtual void GenMethods(string className, Type cls, int indent)
		{
			topMode = (top != null && cls.Equals(top));
			foreach (MethodInfo method in cls.GetMethods())
			{
				string retName = method.ReturnType.Name;
				if (method.Name[0] == '$')
				{
					GenAttributeMethod(className, method, indent);
				}
				else
				{
					if (IsElement(retName))
					{
						GenNewElementMethod(className, method, indent);
					}
					else
					{
						GenCurElementMethod(className, method, indent);
					}
				}
			}
		}

		internal virtual void GenAttributeMethod(string className, MethodInfo method, int
			 indent)
		{
			string methodName = method.Name;
			string attrName = Sharpen.Runtime.Substring(methodName, 1).Replace('_', '-');
			Type[] @params = method.GetGenericParameterTypes();
			Echo(indent, "\n", "@Override\n", "public ", className, topMode ? " " : "<T> ", methodName
				, "(");
			if (@params.Length == 0)
			{
				Puts(0, ") {");
				Puts(indent, "  addAttr(\"", attrName, "\", null);\n", "  return this;\n", "}");
			}
			else
			{
				if (@params.Length == 1)
				{
					string typeName = GetTypeName(@params[0]);
					Puts(0, typeName, " value) {");
					if (typeName.Equals("EnumSet<LinkType>"))
					{
						Puts(indent, "  addRelAttr(\"", attrName, "\", value);\n", "  return this;\n", "}"
							);
					}
					else
					{
						if (typeName.Equals("EnumSet<Media>"))
						{
							Puts(indent, "  addMediaAttr(\"", attrName, "\", value);\n", "  return this;\n", 
								"}");
						}
						else
						{
							Puts(indent, "  addAttr(\"", attrName, "\", value);\n", "  return this;\n", "}");
						}
					}
				}
				else
				{
					ThrowUnhandled(className, method);
				}
			}
		}

		internal virtual string GetTypeName(Type type)
		{
			if (type is Type)
			{
				return ((Type)type).Name;
			}
			ParameterizedType pt = (ParameterizedType)type;
			return ((Type)pt.GetRawType()).Name + "<" + ((Type)pt.GetActualTypeArguments()[0]
				).Name + ">";
		}

		internal virtual void GenFactoryMethod(string retName, string methodName, int indent
			)
		{
			Puts(indent, "\n", "private <T extends _> ", retName, "<T> ", methodName, "_(T e, boolean inline) {\n"
				, "  return new ", retName, "<T>(\"", StringUtils.ToLowerCase(retName), "\", e, opt("
				, !endTagOptional.Contains(retName), ", inline, ", retName.Equals("PRE"), ")); }"
				);
		}

		internal virtual void GenNewElementMethod(string className, MethodInfo method, int
			 indent)
		{
			string methodName = method.Name;
			string retName = method.ReturnType.Name;
			Type[] @params = Sharpen.Runtime.GetParameterTypes(method);
			Echo(indent, "\n", "@Override\n", "public ", retName, "<", className, topMode ? "> "
				 : "<T>> ", methodName, "(");
			if (@params.Length == 0)
			{
				Puts(0, ") {");
				Puts(indent, topMode ? string.Empty : "  closeAttrs();\n", "  return ", StringUtils
					.ToLowerCase(retName), "_" + "(this, ", IsInline(className, retName), ");\n", "}"
					);
			}
			else
			{
				if (@params.Length == 1)
				{
					Puts(0, "String selector) {");
					Puts(indent, "  return setSelector(", methodName, "(), selector);\n", "}");
				}
				else
				{
					ThrowUnhandled(className, method);
				}
			}
		}

		internal virtual bool IsInline(string container, string className)
		{
			if ((container.Equals("BODY") || container.Equals(hamlet) || container.Equals("HEAD"
				) || container.Equals("HTML")) && (className.Equals("INS") || className.Equals("DEL"
				) || className.Equals("SCRIPT")))
			{
				return false;
			}
			return inlineElements.Contains(className);
		}

		internal virtual void GenCurElementMethod(string className, MethodInfo method, int
			 indent)
		{
			string methodName = method.Name;
			Type[] @params = Sharpen.Runtime.GetParameterTypes(method);
			if (topMode || @params.Length > 0)
			{
				Echo(indent, "\n", "@Override\n", "public ", className, topMode ? " " : "<T> ", methodName
					, "(");
			}
			if (@params.Length == 0)
			{
				if (topMode)
				{
					Puts(0, ") {");
					Puts(indent, "  return this;\n", "}");
				}
			}
			else
			{
				if (@params.Length == 1)
				{
					if (methodName.Equals("base"))
					{
						Puts(0, "String href) {");
						Puts(indent, "  return base().$href(href)._();\n", "}");
					}
					else
					{
						if (methodName.Equals("script"))
						{
							Puts(0, "String src) {");
							Puts(indent, "  return setScriptSrc(script(), src)._();\n", "}");
						}
						else
						{
							if (methodName.Equals("style"))
							{
								Puts(0, "Object... lines) {");
								Puts(indent, "  return style().$type(\"text/css\")._(lines)._();\n", "}");
							}
							else
							{
								if (methodName.Equals("img"))
								{
									Puts(0, "String src) {");
									Puts(indent, "  return ", methodName, "().$src(src)._();\n", "}");
								}
								else
								{
									if (methodName.Equals("br") || methodName.Equals("hr") || methodName.Equals("col"
										))
									{
										Puts(0, "String selector) {");
										Puts(indent, "  return setSelector(", methodName, "(), selector)._();\n", "}");
									}
									else
									{
										if (methodName.Equals("link"))
										{
											Puts(0, "String href) {");
											Puts(indent, "  return setLinkHref(", methodName, "(), href)._();\n", "}");
										}
										else
										{
											if (methodName.Equals("_"))
											{
												if (@params[0].Name.Equals("Class"))
												{
													Puts(0, "Class<? extends SubView> cls) {");
													Puts(indent, "  ", topMode ? "subView" : "_v", "(cls);\n", "  return this;\n", "}"
														);
												}
												else
												{
													Puts(0, "Object... lines) {");
													Puts(indent, "  _p(", NeedsEscaping(className), ", lines);\n", "  return this;\n"
														, "}");
												}
											}
											else
											{
												if (methodName.Equals("_r"))
												{
													Puts(0, "Object... lines) {");
													Puts(indent, "  _p(false, lines);\n", "  return this;\n", "}");
												}
												else
												{
													Puts(0, "String cdata) {");
													Puts(indent, "  return ", methodName, "()._(cdata)._();\n", "}");
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					if (@params.Length == 2)
					{
						if (methodName.Equals("meta"))
						{
							Puts(0, "String name, String content) {");
							Puts(indent, "  return meta().$name(name).$content(content)._();\n", "}");
						}
						else
						{
							if (methodName.Equals("meta_http"))
							{
								Puts(0, "String header, String content) {");
								Puts(indent, "  return meta().$http_equiv(header).$content(content)._();\n", "}");
							}
							else
							{
								if (methodName.Equals("a"))
								{
									Puts(0, "String href, String anchorText) {");
									Puts(indent, "  return a().$href(href)._(anchorText)._();\n", "}");
								}
								else
								{
									if (methodName.Equals("bdo"))
									{
										Puts(0, "Dir dir, String cdata) {");
										Puts(indent, "  return bdo().$dir(dir)._(cdata)._();\n", "}");
									}
									else
									{
										if (methodName.Equals("label"))
										{
											Puts(0, "String forId, String cdata) {");
											Puts(indent, "  return label().$for(forId)._(cdata)._();\n", "}");
										}
										else
										{
											if (methodName.Equals("param"))
											{
												Puts(0, "String name, String value) {");
												Puts(indent, "  return param().$name(name).$value(value)._();\n", "}");
											}
											else
											{
												Puts(0, "String selector, String cdata) {");
												Puts(indent, "  return setSelector(", methodName, "(), selector)._(cdata)._();\n"
													, "}");
											}
										}
									}
								}
							}
						}
					}
					else
					{
						if (@params.Length == 3)
						{
							if (methodName.Equals("a"))
							{
								Puts(0, "String selector, String href, String anchorText) {");
								Puts(indent, "  return setSelector(a(), selector)", ".$href(href)._(anchorText)._();\n"
									, "}");
							}
						}
						else
						{
							ThrowUnhandled(className, method);
						}
					}
				}
			}
		}

		internal static bool NeedsEscaping(string eleName)
		{
			return !eleName.Equals("SCRIPT") && !eleName.Equals("STYLE");
		}

		internal static void ThrowUnhandled(string className, MethodInfo method)
		{
			throw new WebAppException("Unhandled " + className + "#" + method);
		}

		internal virtual void Echo(int indent, params object[] args)
		{
			string prev = null;
			foreach (object o in args)
			{
				string s = o.ToString();
				if (!s.IsEmpty() && !s.Equals("\n") && (prev == null || prev.EndsWith("\n")))
				{
					Indent(indent);
				}
				prev = s;
				@out.Write(s);
				bytes += s.Length;
			}
		}

		internal virtual void Indent(int indent)
		{
			for (int i = 0; i < indent; ++i)
			{
				@out.Write("  ");
				bytes += 2;
			}
		}

		internal virtual void Puts(int indent, params object[] args)
		{
			Echo(indent, args);
			@out.WriteLine();
			++bytes;
		}

		internal virtual bool IsElement(string s)
		{
			return elementRegex.Matcher(s).Matches();
		}

		/// <exception cref="System.Exception"/>
		public static void Main(string[] args)
		{
			CommandLine cmd = new GnuParser().Parse(opts, args);
			if (cmd.HasOption("help"))
			{
				new HelpFormatter().PrintHelp("Usage: hbgen [OPTIONS]", opts);
				return;
			}
			// defaults
			Type specClass = typeof(HamletSpec);
			Type implClass = typeof(HamletImpl);
			string outputClass = "HamletTmp";
			string outputPackage = implClass.Assembly.GetName();
			if (cmd.HasOption("spec-class"))
			{
				specClass = Sharpen.Runtime.GetType(cmd.GetOptionValue("spec-class"));
			}
			if (cmd.HasOption("impl-class"))
			{
				implClass = Sharpen.Runtime.GetType(cmd.GetOptionValue("impl-class"));
			}
			if (cmd.HasOption("output-class"))
			{
				outputClass = cmd.GetOptionValue("output-class");
			}
			if (cmd.HasOption("output-package"))
			{
				outputPackage = cmd.GetOptionValue("output-package");
			}
			new HamletGen().Generate(specClass, implClass, outputClass, outputPackage);
		}
	}
}
